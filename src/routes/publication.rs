/*
 * Silex website builder, free/libre no-code tool for makers.
 * Copyright (c) 2023 lexoyo and Silex Labs foundation
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or any later version.
 */

//! Publication API routes
//!
//! Handles website publication operations.
//!
//! Routes:
//! - POST /api/publication/ - Publish website
//! - GET /api/publication/status?jobId=X - Get publication status

use axum::extract::{Query, State};
use axum::routing::{get, post};
use axum::{Json, Router};
use serde::{Deserialize, Serialize};
use tower_sessions::Session;

use crate::connectors::{HostingConnector, StorageConnector};
use crate::error::{ConnectorError, ConnectorResult};
use crate::models::{
    ConnectorFile, JobId, PublicationJobData, WebsiteId,
};
use crate::routes::AppState;

/// Build publication routes
pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/", post(publish))
        .route("/publication/status", get(get_status))
}

// ==================
// Query parameter types
// ==================

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PublishQuery {
    pub website_id: WebsiteId,
    pub hosting_id: String,
    pub storage_id: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct StatusQuery {
    pub job_id: JobId,
}

// ==================
// Request/Response types
// ==================

/// Publication request body
///
/// Contains the files to publish. The request body may also include
/// website data fields (pages, styles, etc.) which are ignored here
/// but could be used by event hooks in the future.
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PublishRequest {
    /// Files to publish (generated by the client)
    #[serde(default)]
    pub files: Vec<ClientSideFile>,
}

/// A file from the client to be published
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ClientSideFile {
    /// Path where the file should be written
    pub path: String,

    /// File content (if provided directly)
    #[serde(default)]
    pub content: Option<String>,

    /// Source path to read content from (if not provided directly)
    #[serde(default)]
    pub src: Option<String>,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PublishResponse {
    /// URL where the website is published
    pub url: String,

    /// Publication job data
    pub job: PublicationJobData,
}

// ==================
// Route handlers
// ==================

/// Publish a website
///
/// POST /api/publication/?websiteId=X&hostingId=X
async fn publish(
    State(state): State<AppState>,
    session: Session,
    Query(query): Query<PublishQuery>,
    Json(request): Json<PublishRequest>,
) -> ConnectorResult<Json<PublishResponse>> {
    let session_data = get_session_data(&session).await;

    // Get the hosting connector
    let hosting_connector = get_hosting_connector(&state, &session_data, &query.hosting_id).await?;

    // Get the storage connector (needed to read assets referenced by src)
    let storage_connector = get_storage_connector(&state, &session_data, query.storage_id.as_deref()).await?;

    // Convert client-side files to connector files
    // Files can have content directly, or a src path to read from storage
    let mut files: Vec<ConnectorFile> = Vec::new();
    for f in request.files {
        if let Some(content) = f.content {
            files.push(ConnectorFile {
                path: f.path,
                content: content.into_bytes(),
            });
        } else if let Some(src) = f.src {
            // Sanitize src: if it's a full URL or API path, extract just the asset filename
            let asset_name = sanitize_asset_src(&src);
            let content = storage_connector
                .read_asset(&session_data, &query.website_id, &asset_name)
                .await?;
            files.push(ConnectorFile {
                path: f.path,
                content,
            });
        } else {
            return Err(ConnectorError::InvalidInput(
                format!("File '{}' has neither content nor src", f.path),
            ));
        }
    }

    // Create a job manager for this publication
    let job_manager = state.job_manager();

    // Publish the website
    let job = hosting_connector
        .publish(&session_data, &query.website_id, files, &job_manager)
        .await?;

    // Get the published URL
    let url = hosting_connector
        .get_url(&session_data, &query.website_id)
        .await?;

    Ok(Json(PublishResponse { url, job }))
}

/// Get publication status
///
/// GET /api/publication/status?jobId=X
async fn get_status(
    State(state): State<AppState>,
    Query(query): Query<StatusQuery>,
) -> ConnectorResult<Json<PublicationJobData>> {
    let job_manager = state.job_manager();

    let job = job_manager
        .get_job(&query.job_id)
        .ok_or_else(|| ConnectorError::NotFound(format!("Job not found: {}", query.job_id)))?;

    Ok(Json(job))
}

// ==================
// Helper functions
// ==================

/// Get session data as JSON value
async fn get_session_data(session: &Session) -> serde_json::Value {
    session
        .get::<serde_json::Value>("data")
        .await
        .ok()
        .flatten()
        .unwrap_or_else(|| serde_json::json!({}))
}

/// Get the storage connector, checking authentication
async fn get_storage_connector(
    state: &AppState,
    session_data: &serde_json::Value,
    connector_id: Option<&str>,
) -> ConnectorResult<std::sync::Arc<dyn StorageConnector>> {
    let connector = state
        .registry
        .get_storage_connector_or_default(connector_id)
        .ok_or_else(|| {
            ConnectorError::NotFound(format!(
                "Storage connector not found: {:?}",
                connector_id
            ))
        })?;

    if !connector.is_logged_in(session_data).await? {
        return Err(ConnectorError::NotAuthenticated);
    }

    Ok(connector)
}

/// Sanitize an asset src path that may be a full URL or API path
///
/// The client may send:
/// - Just a filename: "portrait-alex.jpg"
/// - A stored path: "/assets/portrait-alex.jpg"
/// - An API path: "/api/website/assets/portrait-alex.jpg?websiteId=...&connectorId=..."
/// - A full URL: "http://localhost:6805/api/website/assets/portrait-alex.jpg?websiteId=...&connectorId=..."
///
/// This function extracts just the asset filename in all cases.
fn sanitize_asset_src(src: &str) -> String {
    // Try to extract the path after "/api/website/assets/"
    if let Some(pos) = src.find("/api/website/assets/") {
        let after = &src[pos + "/api/website/assets/".len()..];
        // Strip query params if present
        let name = after.split('?').next().unwrap_or(after);
        return name.to_string();
    }
    // Strip leading "/assets/" prefix
    if let Some(stripped) = src.strip_prefix("/assets/") {
        return stripped.to_string();
    }
    // Return as-is (already a filename)
    src.to_string()
}

/// Get the hosting connector, checking authentication
async fn get_hosting_connector(
    state: &AppState,
    session_data: &serde_json::Value,
    connector_id: &str,
) -> ConnectorResult<std::sync::Arc<dyn HostingConnector>> {
    let connector = state
        .registry
        .get_hosting_connector(connector_id)
        .ok_or_else(|| {
            ConnectorError::NotFound(format!("Hosting connector not found: {}", connector_id))
        })?;

    if !connector.is_logged_in(session_data).await? {
        return Err(ConnectorError::NotAuthenticated);
    }

    Ok(connector)
}
